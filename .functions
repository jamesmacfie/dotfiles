#Take notes
function n() {
				$EDITOR ~/Dropbox/Notes/"$*".txt
}
function nls() {
				ls -c ~/Dropbox/Notes/ | grep "$*"
}

## XERO TEAMCITY ##

function t() {
	if [ $# -eq 0 ]
	then
		open "https://teamcity.dev.xero.com"
		return
	fi

	open "https://teamcity.dev.xero.com/project.html?projectId=$1&tab=projectOverview"
}

## XERO GITHUB ##

# VARIABLES
GHURL=`git config xero.url`
GHME=`git config xero.username`

function x() {
	if [ $# -eq 0 ]
	then
		echo "You need to give Xero Github something to do"
		return
	fi

	case "$1" in

	--help) x-help "${@:2}"
			;;
	o) x-open "${@:2}"
			;;
	n) x-stash-new "${@:2}"
			;;
	p) x-pull-request "${@:2}"
			;;
	pr) x-pull-request "${@:2}"
			;;
	cp) x-commit-push "${@:2}"
			;;
	y) x-commit-push-pull-request "${@:2}"
			;;
	rm) x-delete-branch "${@:2}"
			;;
	*) echo "Xero Github: '$1' is not a git command. See 'xg --help'"
		 ;;
	esac
}

function x-help() {
	green='\x1B[0;32m' 	#Green text
	red='\x1B[1;31m'		#Light red text
	cyan='\x1B[0;36m'	#Cyan text
	purple='\x1B[1;35m'	#Purple text
	orange='\x1B[0;33m'	#Orange text
	nc='\x1B[0m'				#No colour text

	if [ $# -eq 0 ]
		then
			echo ""
			echo -e "${orange}USAGE${nc}"
			echo -e "\t${red}x ${green}[command]${nc}"
			echo ""
			echo -e "${orange}DESCRIPTION${nc}"
			echo -e "\tThese Xero github functions provide a helper layer between Xero's github enterprise"
			echo -e "\tand the command line. They also provide some helper functionality that abstracts away"
			echo -e "\tsome of the git commands so you dont have to type as much."
			echo ""
			echo -e "${orange}COMMANDS${nc}"
			echo -e "\t${green}o${nc}\tOpens up the Xero github page for the repo in the directory you are in"
			echo -e "\t${green}n${nc}\tStashes any changes you have made to the current branch and creates a new"
			echo -e "\t\ttbranch off of the branch specified in the arguments"
			echo -e "\t${green}p${nc}\tOpens up the pull request page with the correct dropdowns filled in based"
			echo -e "\t\toff the specified repo and branhes"
			echo -e "\t${green}pr${nc}\tAlias for [-p]"
			echo -e "\t${green}cp${nc}\tCommits the current code with the supplied message and pushes the changes"
			echo -e "\t\tto origin"
			echo -e "\t${green}y${nc}\tCommits the current code with the supplied message, pushes the changes to"
			echo -e "\t\torigin and opens up the pull request page with the correct dropdowns filled"
			echo -e "\t${green}rm${nc}\tRemoves a branch (both locally and on origin)"
			echo -e "\t\tin"

			echo -e "For further help type ${red}x --help ${green}[command]${nc}"
			echo ""
		return
	fi

	if [ $# -eq 1 ]
		then
			case "$1" in
				o)	echo ""
						echo -e "${orange}USAGE${nx}"
						echo -e "\t${red}x ${cyan}o ${green}[repoName]${nc}"
						echo ""
						echo -e "${orange}DESCRIPTION${nc}"
						echo -e "\tOpens up the repository Xero Github page in your browser"
						echo ""
						echo -e "${orange}EXAMPLE${nc}"
						echo -e "\t${red}x ${cyan}o ${green}xero${nc}"
						echo ""
						;;
				n)	echo ""
						echo -e "${orange}USAGE${nc}"
						echo -e "\t${red}x ${cyan}n ${green}[branchOffName] [newBranchName]${nc}"
						echo ""
						echo -e "${orange}DESCRIPTION${nc}"
						echo -e "\tStashes any changes you have made and checks out the branch specified in the"
						echo -e "\tfirst argument. Once that branch has been checked out, it then creates a new"
						echo -e "\tbranch with the name of the second argument."
						echo ""
						echo -e "${orange}EXAMPLE${nc}"
						echo -e "\t${red}x ${cyan}n ${green}develop newBranch${nc}"
						echo ""
						;;
				p)	echo ""
						echo -e "${orange}USAGE${nc}"
						echo -e "\t${red}x ${cyan}p${nc}"
						echo -e "\t${red}x ${cyan}p ${green}[repoName]${nc}"
						echo -e "\t${red}x ${cyan}p ${green}[branchToMergeTo] [branchToMergeFrom]${nc}"
						echo -e "\t${red}x ${cyan}p ${green}[repoName] [branchToMergeTo] [branchToMergeFrom]${nc}"
						echo ""
						echo -e "${orange}DESCRIPTION${nc}"
						echo -e "\tOpens Xero Github in your browser with all the correct info entered into the"
						echo -e "\tto / from dropdowns (because they are a right pain in the ass to fill in). If you"
						echo -e "\tenter any branch names incorrectly, github (or this script) isn't smart enough"
						echo -e "\tto know that you did a typo and will show you a diff between branches that don't"
						echo -e "\tactually exist."
						echo ""
						echo -e "\tIf no parameters are given and the current folder is a working git repo then"
						echo -e "\tthis will open up the pull request page in the browser."
						echo ""
						echo -e "\tIf one parameter is given then it is assumed that is the name of the repo you"
						echo -e "\twant to view the pull requests for. That repos pull requests will be opened in"
						echo -e "\tyour browser"
						echo ""
						echo -e "\tIf two parameters are given and the current folder is a working git repo then"
						echo -e "\tit will open up a pull request for the current repo."
						echo ""
						echo -e "${orange}EXAMPLE${nc}"
						echo -e "\t${red}x ${cyan}p${nc}"
						echo -e "\t${red}x ${cyan}p ${green}content${nc}${nc}"
						echo -e "\t${red}x ${cyan}p ${green}develop newBranch${nc}${nc}"
						echo -e "\t${red}x ${cyan}p ${green}content develop newBranch${nc}"
						echo ""
						;;
				pr) echo ""
						echo "Alias for ${cyan}p${nc}"
						echo ""
						;;
				cp) echo ""
						echo -e "${orange}USAGE${nc}"
						echo -e "\t${red}x ${cyan}cp ${green}\"message\"${nc}"
						echo ""
						echo -e "${orange}DESCRIPTION${nc}"
						echo -e "\tCommits any code changes with the supplied message and then pushes those up to"
						echo -e "\tyour origin. Essentially just the same as doing 'git commit -am \"message\" &&"
						echo -e "\tgit push origin [branch]' (where [branch] is the branch you currently have"
						echo -e "\tchecked out)"
						echo ""
						echo -e "${orange}EXAMPLES${nc}"
						echo -e "\t${red}x ${cyan}cp ${green}\"Here is my commit message\"${nc}"
						echo ""
						;;
				y) 	echo ""
						echo -e "${orange}USAGE${nc}"
						echo -e "\t${red}x ${cyan}y ${green}\"message\" [branchName]${nc}"
						echo ""
						echo -e "\tCommits any code changes with the supplied message and then pushes those up to"
						echo -e "\tyour origin. Once the code is on your origin then it opens up Xero Github in"
						echo -e "\tyour browser on the pull request page with all the dropdowns filled in correctly."
						echo -e "\tEssentially the same as using 'x cp' and 'x p' with the correct parameters."
						echo ""
						echo -e "${orange}EXAMPLES${nc}"
						echo -e "\t${red}x ${cyan}y ${green}\"Here is my commit message\" develop${nc}"
						echo ""
						;;
				rm) echo ""
						echo "help for rm"
						echo ""
						;;
			esac
		return
	fi
}

function x-commit-push() {
	if [ $# -eq 0 ]
		then
			echo "You need to enter a commit message"
		return
	fi

	local branch=`git name-rev --name-only HEAD`

	git commit -am "$1"
	git push origin $branch
}

function x-stash-new() {
	if [ $# -lt 2 ]
		then
			echo "You need to enter a branch to branch off and a new branch name (else you might as well just use git checkout -b <branchName>)"
		return
	fi

	git stash
	git checkout $1
	git checkout -b $2
	git stash pop
}

function x-commit-push-pull-request() {
	if [ $# -eq 0 ]
		then
			echo "You need to enter a commit message"
		return
	fi

	if [ $# -eq 1 ]
		then
			echo "You need to enter a commit message and the remote branch for the pull request"
		return
	fi

	local project=`git rev-parse --show-toplevel`
	local repo=`basename "$project"`
	local branch=`git name-rev --name-only HEAD`

	git commit -am "$1"
	git push origin $branch
	open "$GHURL/Xero/$repo/compare/Xero:$2...$GHME:$branch?expand=1"
}

function x-pull-request() {
	if [ $# -eq 0 ]
	then
		#No parameters passed through. Open up the pull requests for the working directory's repo (if any).
		#This will fail if the current folder is not a git repo
		local isGitDir=`git rev-parse --is-inside-work-tree`
		if [ "$isGitDir" == "true" ]
		then
			local project=`git rev-parse --show-toplevel`
			local repo=`basename "$project"`

			open "$GHURL/Xero/$repo/pulls"
			return
		fi
		return
	fi

	if [ $# -eq 1 ]
	then
		open "$GHURL/Xero/$1/pulls"
		return
	fi

	if [ $# -eq 2 ]
	then
		local project=`git rev-parse --show-toplevel`
		local repo=`basename "$project"`

		open "$GHURL/Xero/$repo/compare/Xero:$1...$GHME:$2?expand=1"
		return
	fi

	if [ $# -eq 3 ]
	then
		open "$GHURL/Xero/$1/compare/Xero:$2...$GHME:$3?expand=1"
		return
	fi
}

function x-open() {
	local project=`git rev-parse --show-toplevel`
	local repo=`basename "$project"`

	open "$GHURL/Xero/$repo"
}

function x-delete-branch() {
		if [ $# -eq 0 ]
			then
				echo "You need to enter which branch you want to delete"
			return
		fi

		git push origin --delete "$1"

}

## END XERO GITHUB ##

# Open chrome in a certain URL
function chr() {
	/usr/bin/open -a "/Applications/Google Chrome.app" "http://$1"
}

#Connect to a branch envrionment
function b() {
	if [ $# -eq 0 ]
	then
		echo "You need to specify the branch environment"
		return
	fi
	/usr/bin/open -a "/Applications/Google Chrome.app" "https://go.branch$1.test.xero.com/"
}

# Simple calculator
function calc() {
	local result=""
	result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
	#                       └─ default (when `--mathlib` is used) is 20
	#
	if [[ "$result" == *.* ]]; then
		# improve the output for decimal numbers
		printf "$result" |
		sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
		    -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
		    -e 's/0*$//;s/\.$//'   # remove trailing zeros
	else
		printf "$result"
	fi
	printf "\n"
}

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$@"
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
	local tmpFile="${@%/}.tar"
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

	size=$(
		stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
		stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
	)

	local cmd=""
	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli"
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz"
		else
			cmd="gzip"
		fi
	fi

	echo "Compressing .tar using \`${cmd}\`…"
	"${cmd}" -v "${tmpFile}" || return 1
	[ -f "${tmpFile}" ] && rm "${tmpFile}"
	echo "${tmpFile}.gz created successfully."
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* *
	fi
}

# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@"
	}
fi

# Create a data URL from a file
function dataurl() {
	local mimeType=$(file -b --mime-type "$1")
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8"
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Create a git.io short URL
function gitio() {
	if [ -z "${1}" -o -z "${2}" ]; then
		echo "Usage: \`gitio slug url\`"
		return 1
	fi
	curl -i http://git.io/ -F "url=${2}" -F "code=${1}"
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}"
	sleep 1 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
function phpserver() {
	local port="${1:-4000}"
	local ip=$(ipconfig getifaddr en1)
	sleep 1 && open "http://${ip}:${port}/" &
	php -S "${ip}:${port}"
}

# Compare original and gzipped file size
function gz() {
	local origsize=$(wc -c < "$1")
	local gzipsize=$(gzip -c "$1" | wc -c)
	local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
	printf "orig: %d bytes\n" "$origsize"
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
	if [ -t 0 ]; then # argument
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	else # pipe
		python -mjson.tool | pygmentize -l javascript
	fi
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Escape UTF-8 characters into their 3-byte format
function escape() {
	printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
	# print a newline unless we’re piping the output to another program
	if [ -t 1 ]; then
		echo # newline
	fi
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
	perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
	# print a newline unless we’re piping the output to another program
	if [ -t 1 ]; then
		echo # newline
	fi
}

# Get a character’s Unicode code point
function codepoint() {
	perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
	# print a newline unless we’re piping the output to another program
	if [ -t 1 ]; then
		echo # newline
	fi
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
	if [ -z "${1}" ]; then
		echo "ERROR: No domain specified."
		return 1
	fi

	local domain="${1}"
	echo "Testing ${domain}…"
	echo # newline

	local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
		| openssl s_client -connect "${domain}:443" 2>&1);

	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
		local certText=$(echo "${tmp}" \
			| openssl x509 -text -certopt "no_header, no_serial, no_version, \
			no_signame, no_validity, no_issuer, no_pubkey, no_sigdump, no_aux");
			echo "Common Name:"
			echo # newline
			echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//";
			echo # newline
			echo "Subject Alternative Name(s):"
			echo # newline
			echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
				| sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
			return 0
	else
		echo "ERROR: Certificate not found.";
		return 1
	fi
}

# Add note to Notes.app (OS X 10.8)
# Usage: `note 'title' 'body'` or `echo 'body' | note`
# Title is optional
function note() {
	local title
	local body
	if [ -t 0 ]; then
		title="$1"
		body="$2"
	else
		title=$(cat)
	fi
	osascript >/dev/null <<EOF
tell application "Notes"
	tell account "iCloud"
		tell folder "Notes"
			make new note with properties {name:"$title", body:"$title" & "<br><br>" & "$body"}
		end tell
	end tell
end tell
EOF
}

# Add reminder to Reminders.app (OS X 10.8)
# Usage: `remind 'foo'` or `echo 'foo' | remind`
function remind() {
	local text
	if [ -t 0 ]; then
		text="$1" # argument
	else
		text=$(cat) # pipe
	fi
	osascript >/dev/null <<EOF
tell application "Reminders"
	tell the default list
		make new reminder with properties {name:"$text"}
	end tell
end tell
EOF
}

# Manually remove a downloaded app or file from the quarantine
function unquarantine() {
	for attribute in com.apple.metadata:kMDItemDownloadedDate com.apple.metadata:kMDItemWhereFroms com.apple.quarantine; do
		xattr -r -d "$attribute" "$@"
	done
}

# Install Grunt plugins and add them as `devDependencies` to `package.json`
# Usage: `gi contrib-watch contrib-uglify zopfli`
function gi() {
	local IFS=,
	eval npm install --save-dev grunt-{"$*"}
}
